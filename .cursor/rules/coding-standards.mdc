---
alwaysApply: true
---
# 代码风格和工程开发规范

## 🎨 命名和风格约定

### Rust 标准命名规范

严格遵循 Rust 官方命名约定：

```rust
// ✅ 类型命名：PascalCase
pub struct DataProcessor {}
pub enum ProcessState {}
pub trait Configurable {}

// ✅ 函数和变量：snake_case
pub fn process_data() -> Result<()> {}
let file_path = PathBuf::new();
let mut buffer_size = 8192;

// ✅ 常量：UPPER_SNAKE_CASE
pub const DEFAULT_BUFFER_SIZE: usize = 8192;
const MAX_RETRY_ATTEMPTS: u32 = 3;

// ✅ 模块：snake_case
mod file_processor;
mod data_manager;

// ✅ 生命周期参数：小写字母
fn process_data<'a>(input: &'a str) -> &'a str {}
```

### 可见性控制原则

精确控制模块和字段的可见性：

```rust
// ✅ 公共 API - 谨慎暴露
pub struct PublicService {}        // 用户直接使用
pub fn public_api() -> Result<()> {} // 对外功能

// ✅ 内部实现 - 合理限制
pub(crate) struct InternalHelper {} // 当前 crate 可见
pub(super) fn helper_function() {}   // 父模块可见

// ✅ 私有实现 - 默认隐藏
struct PrivateImpl {}               // 仅当前模块
fn internal_logic() {}              // 内部实现

// ✅ 字段可见性 - 精确控制
pub struct ConfiguredService {
    pub name: String,                    // 用户可访问
    pub(crate) internal_state: State,   // 模块内访问
    config: ServiceConfig,               // 私有配置
}
```

## 📝 注释和文档规范

### 中文文档注释标准

所有公共 API 必须有完整的中文文档：

````rust
/// 高性能数据处理器
///
/// 提供数据的读取、处理、验证和输出功能。支持多种数据格式，
/// 具备自动错误恢复机制和性能优化策略。
///
/// # 特性
/// - 支持批量操作以提高处理效率
/// - 自动资源管理，无需手动清理
/// - 可配置的缓存策略和超时控制
/// - 内置数据验证和错误恢复机制
///
/// # 性能特点
/// - 零拷贝操作减少内存分配
/// - 预分配缓冲区避免频繁扩容
/// - 批量处理减少系统调用开销
///
/// # 示例
/// ```rust
/// use my_crate::{DataProcessor, ProcessConfig};
///
/// let config = ProcessConfig::high_performance();
/// let mut processor = DataProcessor::new(config)?;
///
/// let input_data = load_test_data();
/// let result = processor.process_batch(&input_data)?;
///
/// println!("处理了 {} 条记录", result.processed_count);
/// ```
///
/// # 错误处理
/// 所有方法都返回 `Result` 类型，主要错误包括：
/// - `ProcessError::InvalidInput` - 输入数据格式无效
/// - `ProcessError::ResourceLimit` - 超出资源限制
/// - `ProcessError::Timeout` - 操作超时
pub struct DataProcessor {
    config: ProcessConfig,
    // 其他字段...
}

/// 处理单批数据并返回处理结果
///
/// 该方法会验证输入数据格式，执行配置的处理流程，
/// 并返回详细的处理统计信息。
///
/// # 参数
/// * `input_data` - 待处理的输入数据切片，不会修改原数据
/// * `options` - 处理选项，覆盖默认配置中的相应设置
///
/// # 返回值
/// * `Ok(ProcessResult)` - 包含处理统计和结果数据
/// * `Err(ProcessError)` - 处理过程中遇到的错误
///
/// # 性能说明
/// - 输入数据通过引用传递，避免不必要的复制
/// - 内部使用批量处理以提高效率
/// - 预分配输出缓冲区以减少内存重分配
///
/// # 示例
/// ```rust
/// let options = ProcessOptions::default()
///     .with_validation(true)
///     .with_timeout(Duration::from_secs(30));
///
/// match processor.process_batch(&data, options) {
///     Ok(result) => println!("成功处理 {} 条记录", result.count),
///     Err(e) => eprintln!("处理失败: {}", e),
/// }
/// ```
pub fn process_batch(
    &mut self,
    input_data: &[InputItem],
    options: ProcessOptions
) -> Result<ProcessResult, ProcessError> {
    // 实现细节...
}
````

### 代码内注释规范

代码内使用简洁的中文注释说明关键逻辑：

```rust
impl DataProcessor {
    pub fn new(config: ProcessConfig) -> Result<Self, ProcessError> {
        // 验证配置参数的有效性
        config.validate().map_err(|e| ProcessError::InvalidConfig(e))?;

        // 根据配置创建内部组件
        let cache = if config.enable_cache {
            Some(DataCache::with_capacity(config.cache_size))
        } else {
            None
        };

        // 初始化处理器状态
        let processor = Self {
            config,
            cache,
            stats: ProcessStats::new(),
            // 预分配工作缓冲区以提高性能
            work_buffer: Vec::with_capacity(config.buffer_size),
        };

        log::info!("数据处理器初始化完成，配置: {:?}", processor.config);
        Ok(processor)
    }
}
```

## ⚠️ 错误处理规范

### 统一错误类型设计

使用 `thiserror` 创建清晰的错误层次：

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum PcapError {
    #[error("文件未找到: {0}")]
    FileNotFound(String),

    #[error("目录不存在: {0}")]
    DirectoryNotFound(String),

    #[error("无效的文件格式: {0}")]
    InvalidFormat(String),

    #[error("文件头损坏: {0}")]
    CorruptedHeader(String),

    #[error("数据包损坏: {message}，位置 {position}")]
    CorruptedData { message: String, position: u64 },

    #[error("校验和不匹配: 期望 {expected}, 实际 {actual}，位置 {position}")]
    ChecksumMismatch { expected: String, actual: String, position: u64 },

    #[error("数据包大小无效: {message}，位置 {position}")]
    InvalidPacketSize { message: String, position: u64 },

    #[error("参数无效: {0}")]
    InvalidArgument(String),

    #[error("操作状态无效: {0}")]
    InvalidState(String),

    #[error("I/O 操作失败: {source}")]
    Io(#[from] std::io::Error),

    #[error("序列化错误: {0}")]
    Serialization(String),

    #[error("未知错误: {0}")]
    Unknown(String),
}

// 项目统一的 Result 类型
pub type PcapResult<T> = std::result::Result<T, PcapError>;
```

### 分层错误处理策略

在不同层次进行适当的错误转换和上下文添加：

```rust
// 数据访问层：转换底层错误
impl PcapFileReader {
    pub fn read_file<P: AsRef<Path>>(path: P) -> PcapResult<Vec<u8>> {
        std::fs::read(&path).map_err(|io_err| {
            PcapError::Io(io_err)
        })
    }
}

// 业务逻辑层：添加业务上下文
impl PcapReader {
    pub fn load_dataset(&mut self, dataset_path: &Path) -> PcapResult<DatasetInfo> {
        // 尝试读取数据集
        let dataset_info = self.get_dataset_info()
            .map_err(|e| PcapError::InvalidFormat(
                format!("无法读取数据集 {dataset_path:?}: {e}")
            ))?;

        // 验证数据集完整性
        if !dataset_info.has_index {
            return Err(PcapError::InvalidFormat(
                format!("数据集 {dataset_path:?} 缺少索引文件")
            ));
        }

        Ok(dataset_info)
    }
}

// API 层：提供用户友好的错误信息
impl PcapReader {
    pub fn new<P: AsRef<Path>>(base_path: P, dataset_name: &str) -> PcapResult<Self> {
        let path_ref = base_path.as_ref();

        // 检查基础路径是否存在
        if !path_ref.exists() {
            return Err(PcapError::DirectoryNotFound(
                format!("基础路径不存在: {path_ref:?}")
            ));
        }

        // 执行初始化逻辑
        Self::new_with_config(base_path, dataset_name, ReaderConfig::default())
            .map_err(|e| {
                log::error!("创建读取器失败: {}", e);
                e
            })
    }
}
```

### 错误恢复和降级策略

```rust
impl PcapReader {
    pub fn read_with_fallback(&mut self) -> PcapResult<Option<ValidatedPacket>> {
        // 尝试主要读取路径
        match self.read_packet() {
            Ok(Some(packet)) => Ok(Some(packet)),
            Ok(None) => Ok(None), // 正常结束
            Err(PcapError::CorruptedData { .. }) => {
                // 数据损坏时跳过并继续
                log::warn!("发现损坏数据包，跳过继续处理");
                self.read_packet() // 递归尝试下一个
            },
            Err(PcapError::InvalidFormat { .. }) => {
                // 格式错误时尝试重置
                log::warn!("格式错误，尝试重置读取器");
                self.reset()?;
                self.read_packet()
            },
            Err(other) => Err(other), // 其他错误直接返回
        }
    }
}
```

## 🚀 性能优化规范

### 内存使用优化

```rust
// ✅ 优先使用借用避免不必要的克隆
impl DataContainer {
    // 返回引用而不是拷贝
    pub fn get_content(&self) -> &[u8] {
        &self.content
    }

    // 使用 Cow 处理条件性修改
    pub fn get_processed_content(&self) -> Cow<'_, [u8]> {
        if self.needs_processing() {
            Cow::Owned(self.process_content())
        } else {
            Cow::Borrowed(&self.content)
        }
    }
}

// ✅ 预分配容器容量
pub fn collect_all_data(sources: &[DataSource]) -> Vec<DataItem> {
    // 估算总容量避免重复分配
    let estimated_capacity: usize = sources
        .iter()
        .map(|s| s.estimated_item_count())
        .sum();

    let mut items = Vec::with_capacity(estimated_capacity);

    for source in sources {
        items.extend(source.get_items());
    }

    items
}

// ✅ 使用合适的字符串类型
pub fn process_text(input: &str) -> String {  // 参数用 &str，返回 String
    // 处理逻辑
    input.to_uppercase()
}
```

### 零拷贝操作模式

```rust
// ✅ 设计避免不必要数据拷贝的接口
pub trait ZeroCopyProcessor {
    fn process_in_place(&mut self, data: &mut [u8]) -> Result<usize>;
    fn process_slice(&self, input: &[u8], output: &mut [u8]) -> Result<usize>;
}

// ✅ 使用引用链避免中间分配
pub fn chain_processors(
    input: &[u8],
    processors: &[Box<dyn ZeroCopyProcessor>]
) -> Result<Vec<u8>> {
    let mut current = input.to_vec(); // 只在开始时拷贝一次

    for processor in processors {
        let processed_len = processor.process_in_place(&mut current)?;
        current.truncate(processed_len);
    }

    Ok(current)
}
```
