---
alwaysApply: true
---
# ä»£ç é£æ ¼å’Œå·¥ç¨‹å¼€å‘è§„èŒƒ

## ğŸ¨ å‘½åå’Œé£æ ¼çº¦å®š

### Rust æ ‡å‡†å‘½åè§„èŒƒ

ä¸¥æ ¼éµå¾ª Rust å®˜æ–¹å‘½åçº¦å®šï¼š

```rust
// âœ… ç±»å‹å‘½åï¼šPascalCase
pub struct DataProcessor {}
pub enum ProcessState {}
pub trait Configurable {}

// âœ… å‡½æ•°å’Œå˜é‡ï¼šsnake_case
pub fn process_data() -> Result<()> {}
let file_path = PathBuf::new();
let mut buffer_size = 8192;

// âœ… å¸¸é‡ï¼šUPPER_SNAKE_CASE
pub const DEFAULT_BUFFER_SIZE: usize = 8192;
const MAX_RETRY_ATTEMPTS: u32 = 3;

// âœ… æ¨¡å—ï¼šsnake_case
mod file_processor;
mod data_manager;

// âœ… ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼šå°å†™å­—æ¯
fn process_data<'a>(input: &'a str) -> &'a str {}
```

### å¯è§æ€§æ§åˆ¶åŸåˆ™

ç²¾ç¡®æ§åˆ¶æ¨¡å—å’Œå­—æ®µçš„å¯è§æ€§ï¼š

```rust
// âœ… å…¬å…± API - è°¨æ…æš´éœ²
pub struct PublicService {}        // ç”¨æˆ·ç›´æ¥ä½¿ç”¨
pub fn public_api() -> Result<()> {} // å¯¹å¤–åŠŸèƒ½

// âœ… å†…éƒ¨å®ç° - åˆç†é™åˆ¶
pub(crate) struct InternalHelper {} // å½“å‰ crate å¯è§
pub(super) fn helper_function() {}   // çˆ¶æ¨¡å—å¯è§

// âœ… ç§æœ‰å®ç° - é»˜è®¤éšè—
struct PrivateImpl {}               // ä»…å½“å‰æ¨¡å—
fn internal_logic() {}              // å†…éƒ¨å®ç°

// âœ… å­—æ®µå¯è§æ€§ - ç²¾ç¡®æ§åˆ¶
pub struct ConfiguredService {
    pub name: String,                    // ç”¨æˆ·å¯è®¿é—®
    pub(crate) internal_state: State,   // æ¨¡å—å†…è®¿é—®
    config: ServiceConfig,               // ç§æœ‰é…ç½®
}
```

## ğŸ“ æ³¨é‡Šå’Œæ–‡æ¡£è§„èŒƒ

### ä¸­æ–‡æ–‡æ¡£æ³¨é‡Šæ ‡å‡†

æ‰€æœ‰å…¬å…± API å¿…é¡»æœ‰å®Œæ•´çš„ä¸­æ–‡æ–‡æ¡£ï¼š

````rust
/// é«˜æ€§èƒ½æ•°æ®å¤„ç†å™¨
///
/// æä¾›æ•°æ®çš„è¯»å–ã€å¤„ç†ã€éªŒè¯å’Œè¾“å‡ºåŠŸèƒ½ã€‚æ”¯æŒå¤šç§æ•°æ®æ ¼å¼ï¼Œ
/// å…·å¤‡è‡ªåŠ¨é”™è¯¯æ¢å¤æœºåˆ¶å’Œæ€§èƒ½ä¼˜åŒ–ç­–ç•¥ã€‚
///
/// # ç‰¹æ€§
/// - æ”¯æŒæ‰¹é‡æ“ä½œä»¥æé«˜å¤„ç†æ•ˆç‡
/// - è‡ªåŠ¨èµ„æºç®¡ç†ï¼Œæ— éœ€æ‰‹åŠ¨æ¸…ç†
/// - å¯é…ç½®çš„ç¼“å­˜ç­–ç•¥å’Œè¶…æ—¶æ§åˆ¶
/// - å†…ç½®æ•°æ®éªŒè¯å’Œé”™è¯¯æ¢å¤æœºåˆ¶
///
/// # æ€§èƒ½ç‰¹ç‚¹
/// - é›¶æ‹·è´æ“ä½œå‡å°‘å†…å­˜åˆ†é…
/// - é¢„åˆ†é…ç¼“å†²åŒºé¿å…é¢‘ç¹æ‰©å®¹
/// - æ‰¹é‡å¤„ç†å‡å°‘ç³»ç»Ÿè°ƒç”¨å¼€é”€
///
/// # ç¤ºä¾‹
/// ```rust
/// use my_crate::{DataProcessor, ProcessConfig};
///
/// let config = ProcessConfig::high_performance();
/// let mut processor = DataProcessor::new(config)?;
///
/// let input_data = load_test_data();
/// let result = processor.process_batch(&input_data)?;
///
/// println!("å¤„ç†äº† {} æ¡è®°å½•", result.processed_count);
/// ```
///
/// # é”™è¯¯å¤„ç†
/// æ‰€æœ‰æ–¹æ³•éƒ½è¿”å› `Result` ç±»å‹ï¼Œä¸»è¦é”™è¯¯åŒ…æ‹¬ï¼š
/// - `ProcessError::InvalidInput` - è¾“å…¥æ•°æ®æ ¼å¼æ— æ•ˆ
/// - `ProcessError::ResourceLimit` - è¶…å‡ºèµ„æºé™åˆ¶
/// - `ProcessError::Timeout` - æ“ä½œè¶…æ—¶
pub struct DataProcessor {
    config: ProcessConfig,
    // å…¶ä»–å­—æ®µ...
}

/// å¤„ç†å•æ‰¹æ•°æ®å¹¶è¿”å›å¤„ç†ç»“æœ
///
/// è¯¥æ–¹æ³•ä¼šéªŒè¯è¾“å…¥æ•°æ®æ ¼å¼ï¼Œæ‰§è¡Œé…ç½®çš„å¤„ç†æµç¨‹ï¼Œ
/// å¹¶è¿”å›è¯¦ç»†çš„å¤„ç†ç»Ÿè®¡ä¿¡æ¯ã€‚
///
/// # å‚æ•°
/// * `input_data` - å¾…å¤„ç†çš„è¾“å…¥æ•°æ®åˆ‡ç‰‡ï¼Œä¸ä¼šä¿®æ”¹åŸæ•°æ®
/// * `options` - å¤„ç†é€‰é¡¹ï¼Œè¦†ç›–é»˜è®¤é…ç½®ä¸­çš„ç›¸åº”è®¾ç½®
///
/// # è¿”å›å€¼
/// * `Ok(ProcessResult)` - åŒ…å«å¤„ç†ç»Ÿè®¡å’Œç»“æœæ•°æ®
/// * `Err(ProcessError)` - å¤„ç†è¿‡ç¨‹ä¸­é‡åˆ°çš„é”™è¯¯
///
/// # æ€§èƒ½è¯´æ˜
/// - è¾“å…¥æ•°æ®é€šè¿‡å¼•ç”¨ä¼ é€’ï¼Œé¿å…ä¸å¿…è¦çš„å¤åˆ¶
/// - å†…éƒ¨ä½¿ç”¨æ‰¹é‡å¤„ç†ä»¥æé«˜æ•ˆç‡
/// - é¢„åˆ†é…è¾“å‡ºç¼“å†²åŒºä»¥å‡å°‘å†…å­˜é‡åˆ†é…
///
/// # ç¤ºä¾‹
/// ```rust
/// let options = ProcessOptions::default()
///     .with_validation(true)
///     .with_timeout(Duration::from_secs(30));
///
/// match processor.process_batch(&data, options) {
///     Ok(result) => println!("æˆåŠŸå¤„ç† {} æ¡è®°å½•", result.count),
///     Err(e) => eprintln!("å¤„ç†å¤±è´¥: {}", e),
/// }
/// ```
pub fn process_batch(
    &mut self,
    input_data: &[InputItem],
    options: ProcessOptions
) -> Result<ProcessResult, ProcessError> {
    // å®ç°ç»†èŠ‚...
}
````

### ä»£ç å†…æ³¨é‡Šè§„èŒƒ

ä»£ç å†…ä½¿ç”¨ç®€æ´çš„ä¸­æ–‡æ³¨é‡Šè¯´æ˜å…³é”®é€»è¾‘ï¼š

```rust
impl DataProcessor {
    pub fn new(config: ProcessConfig) -> Result<Self, ProcessError> {
        // éªŒè¯é…ç½®å‚æ•°çš„æœ‰æ•ˆæ€§
        config.validate().map_err(|e| ProcessError::InvalidConfig(e))?;

        // æ ¹æ®é…ç½®åˆ›å»ºå†…éƒ¨ç»„ä»¶
        let cache = if config.enable_cache {
            Some(DataCache::with_capacity(config.cache_size))
        } else {
            None
        };

        // åˆå§‹åŒ–å¤„ç†å™¨çŠ¶æ€
        let processor = Self {
            config,
            cache,
            stats: ProcessStats::new(),
            // é¢„åˆ†é…å·¥ä½œç¼“å†²åŒºä»¥æé«˜æ€§èƒ½
            work_buffer: Vec::with_capacity(config.buffer_size),
        };

        log::info!("æ•°æ®å¤„ç†å™¨åˆå§‹åŒ–å®Œæˆï¼Œé…ç½®: {:?}", processor.config);
        Ok(processor)
    }
}
```

## âš ï¸ é”™è¯¯å¤„ç†è§„èŒƒ

### ç»Ÿä¸€é”™è¯¯ç±»å‹è®¾è®¡

ä½¿ç”¨ `thiserror` åˆ›å»ºæ¸…æ™°çš„é”™è¯¯å±‚æ¬¡ï¼š

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum PcapError {
    #[error("æ–‡ä»¶æœªæ‰¾åˆ°: {0}")]
    FileNotFound(String),

    #[error("ç›®å½•ä¸å­˜åœ¨: {0}")]
    DirectoryNotFound(String),

    #[error("æ— æ•ˆçš„æ–‡ä»¶æ ¼å¼: {0}")]
    InvalidFormat(String),

    #[error("æ–‡ä»¶å¤´æŸå: {0}")]
    CorruptedHeader(String),

    #[error("æ•°æ®åŒ…æŸå: {message}ï¼Œä½ç½® {position}")]
    CorruptedData { message: String, position: u64 },

    #[error("æ ¡éªŒå’Œä¸åŒ¹é…: æœŸæœ› {expected}, å®é™… {actual}ï¼Œä½ç½® {position}")]
    ChecksumMismatch { expected: String, actual: String, position: u64 },

    #[error("æ•°æ®åŒ…å¤§å°æ— æ•ˆ: {message}ï¼Œä½ç½® {position}")]
    InvalidPacketSize { message: String, position: u64 },

    #[error("å‚æ•°æ— æ•ˆ: {0}")]
    InvalidArgument(String),

    #[error("æ“ä½œçŠ¶æ€æ— æ•ˆ: {0}")]
    InvalidState(String),

    #[error("I/O æ“ä½œå¤±è´¥: {source}")]
    Io(#[from] std::io::Error),

    #[error("åºåˆ—åŒ–é”™è¯¯: {0}")]
    Serialization(String),

    #[error("æœªçŸ¥é”™è¯¯: {0}")]
    Unknown(String),
}

// é¡¹ç›®ç»Ÿä¸€çš„ Result ç±»å‹
pub type PcapResult<T> = std::result::Result<T, PcapError>;
```

### åˆ†å±‚é”™è¯¯å¤„ç†ç­–ç•¥

åœ¨ä¸åŒå±‚æ¬¡è¿›è¡Œé€‚å½“çš„é”™è¯¯è½¬æ¢å’Œä¸Šä¸‹æ–‡æ·»åŠ ï¼š

```rust
// æ•°æ®è®¿é—®å±‚ï¼šè½¬æ¢åº•å±‚é”™è¯¯
impl PcapFileReader {
    pub fn read_file<P: AsRef<Path>>(path: P) -> PcapResult<Vec<u8>> {
        std::fs::read(&path).map_err(|io_err| {
            PcapError::Io(io_err)
        })
    }
}

// ä¸šåŠ¡é€»è¾‘å±‚ï¼šæ·»åŠ ä¸šåŠ¡ä¸Šä¸‹æ–‡
impl PcapReader {
    pub fn load_dataset(&mut self, dataset_path: &Path) -> PcapResult<DatasetInfo> {
        // å°è¯•è¯»å–æ•°æ®é›†
        let dataset_info = self.get_dataset_info()
            .map_err(|e| PcapError::InvalidFormat(
                format!("æ— æ³•è¯»å–æ•°æ®é›† {dataset_path:?}: {e}")
            ))?;

        // éªŒè¯æ•°æ®é›†å®Œæ•´æ€§
        if !dataset_info.has_index {
            return Err(PcapError::InvalidFormat(
                format!("æ•°æ®é›† {dataset_path:?} ç¼ºå°‘ç´¢å¼•æ–‡ä»¶")
            ));
        }

        Ok(dataset_info)
    }
}

// API å±‚ï¼šæä¾›ç”¨æˆ·å‹å¥½çš„é”™è¯¯ä¿¡æ¯
impl PcapReader {
    pub fn new<P: AsRef<Path>>(base_path: P, dataset_name: &str) -> PcapResult<Self> {
        let path_ref = base_path.as_ref();

        // æ£€æŸ¥åŸºç¡€è·¯å¾„æ˜¯å¦å­˜åœ¨
        if !path_ref.exists() {
            return Err(PcapError::DirectoryNotFound(
                format!("åŸºç¡€è·¯å¾„ä¸å­˜åœ¨: {path_ref:?}")
            ));
        }

        // æ‰§è¡Œåˆå§‹åŒ–é€»è¾‘
        Self::new_with_config(base_path, dataset_name, ReaderConfig::default())
            .map_err(|e| {
                log::error!("åˆ›å»ºè¯»å–å™¨å¤±è´¥: {}", e);
                e
            })
    }
}
```

### é”™è¯¯æ¢å¤å’Œé™çº§ç­–ç•¥

```rust
impl PcapReader {
    pub fn read_with_fallback(&mut self) -> PcapResult<Option<ValidatedPacket>> {
        // å°è¯•ä¸»è¦è¯»å–è·¯å¾„
        match self.read_packet() {
            Ok(Some(packet)) => Ok(Some(packet)),
            Ok(None) => Ok(None), // æ­£å¸¸ç»“æŸ
            Err(PcapError::CorruptedData { .. }) => {
                // æ•°æ®æŸåæ—¶è·³è¿‡å¹¶ç»§ç»­
                log::warn!("å‘ç°æŸåæ•°æ®åŒ…ï¼Œè·³è¿‡ç»§ç»­å¤„ç†");
                self.read_packet() // é€’å½’å°è¯•ä¸‹ä¸€ä¸ª
            },
            Err(PcapError::InvalidFormat { .. }) => {
                // æ ¼å¼é”™è¯¯æ—¶å°è¯•é‡ç½®
                log::warn!("æ ¼å¼é”™è¯¯ï¼Œå°è¯•é‡ç½®è¯»å–å™¨");
                self.reset()?;
                self.read_packet()
            },
            Err(other) => Err(other), // å…¶ä»–é”™è¯¯ç›´æ¥è¿”å›
        }
    }
}
```

## ğŸš€ æ€§èƒ½ä¼˜åŒ–è§„èŒƒ

### å†…å­˜ä½¿ç”¨ä¼˜åŒ–

```rust
// âœ… ä¼˜å…ˆä½¿ç”¨å€Ÿç”¨é¿å…ä¸å¿…è¦çš„å…‹éš†
impl DataContainer {
    // è¿”å›å¼•ç”¨è€Œä¸æ˜¯æ‹·è´
    pub fn get_content(&self) -> &[u8] {
        &self.content
    }

    // ä½¿ç”¨ Cow å¤„ç†æ¡ä»¶æ€§ä¿®æ”¹
    pub fn get_processed_content(&self) -> Cow<'_, [u8]> {
        if self.needs_processing() {
            Cow::Owned(self.process_content())
        } else {
            Cow::Borrowed(&self.content)
        }
    }
}

// âœ… é¢„åˆ†é…å®¹å™¨å®¹é‡
pub fn collect_all_data(sources: &[DataSource]) -> Vec<DataItem> {
    // ä¼°ç®—æ€»å®¹é‡é¿å…é‡å¤åˆ†é…
    let estimated_capacity: usize = sources
        .iter()
        .map(|s| s.estimated_item_count())
        .sum();

    let mut items = Vec::with_capacity(estimated_capacity);

    for source in sources {
        items.extend(source.get_items());
    }

    items
}

// âœ… ä½¿ç”¨åˆé€‚çš„å­—ç¬¦ä¸²ç±»å‹
pub fn process_text(input: &str) -> String {  // å‚æ•°ç”¨ &strï¼Œè¿”å› String
    // å¤„ç†é€»è¾‘
    input.to_uppercase()
}
```

### é›¶æ‹·è´æ“ä½œæ¨¡å¼

```rust
// âœ… è®¾è®¡é¿å…ä¸å¿…è¦æ•°æ®æ‹·è´çš„æ¥å£
pub trait ZeroCopyProcessor {
    fn process_in_place(&mut self, data: &mut [u8]) -> Result<usize>;
    fn process_slice(&self, input: &[u8], output: &mut [u8]) -> Result<usize>;
}

// âœ… ä½¿ç”¨å¼•ç”¨é“¾é¿å…ä¸­é—´åˆ†é…
pub fn chain_processors(
    input: &[u8],
    processors: &[Box<dyn ZeroCopyProcessor>]
) -> Result<Vec<u8>> {
    let mut current = input.to_vec(); // åªåœ¨å¼€å§‹æ—¶æ‹·è´ä¸€æ¬¡

    for processor in processors {
        let processed_len = processor.process_in_place(&mut current)?;
        current.truncate(processed_len);
    }

    Ok(current)
}
```
