---
alwaysApply: true
---
# ç³»ç»Ÿæ¶æ„è®¾è®¡åŸåˆ™è§„èŒƒ

## ğŸ—ï¸ åˆ†å±‚æ¶æ„è®¾è®¡

### æ ‡å‡†å››å±‚æ¶æ„

ä¸¥æ ¼éµå¾ªåˆ†å±‚æ¶æ„ï¼Œç¡®ä¿ç³»ç»Ÿçš„å¯ç»´æŠ¤æ€§å’Œå¯æ‰©å±•æ€§ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    ç”¨æˆ·æ¥å£å±‚ (API Layer)           â”‚  â† å¯¹å¤–æä¾›æœåŠ¡æ¥å£
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    ä¸šåŠ¡é€»è¾‘å±‚ (Business Layer)      â”‚  â† æ ¸å¿ƒä¸šåŠ¡é€»è¾‘å®ç°
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    æ•°æ®è®¿é—®å±‚ (Data Layer)          â”‚  â† æ•°æ®æ“ä½œå’Œæ ¼å¼å¤„ç†
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    åŸºç¡€è®¾æ–½å±‚ (Infrastructure)      â”‚  â† å·¥å…·å‡½æ•°å’Œé€šç”¨ç»„ä»¶
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### å±‚æ¬¡èŒè´£å®šä¹‰

**ç”¨æˆ·æ¥å£å±‚** - ç®€æ´çš„å¯¹å¤–æ¥å£

- æä¾›ç”¨æˆ·å‹å¥½çš„ API
- éšè—å†…éƒ¨å®ç°å¤æ‚æ€§
- å¤„ç†å‚æ•°éªŒè¯å’Œæ ¼å¼è½¬æ¢
- å®ç°èµ„æºçš„è‡ªåŠ¨åŒ–ç®¡ç†

**ä¸šåŠ¡é€»è¾‘å±‚** - æ ¸å¿ƒåŠŸèƒ½å®ç°

- å…·ä½“ä¸šåŠ¡è§„åˆ™å’Œç®—æ³•
- é…ç½®ç®¡ç†å’Œç­–ç•¥æ§åˆ¶
- ç¼“å­˜å’Œç´¢å¼•ç­‰æ€§èƒ½ä¼˜åŒ–
- ä¸šåŠ¡æµç¨‹ç¼–æ’

**æ•°æ®è®¿é—®å±‚** - æ•°æ®æ“ä½œæŠ½è±¡

- æ–‡ä»¶ I/O å’Œç½‘ç»œæ“ä½œ
- æ•°æ®åºåˆ—åŒ–/ååºåˆ—åŒ–
- æ ¼å¼è§£æå’Œç”Ÿæˆ
- åº•å±‚å­˜å‚¨æ“ä½œ

**åŸºç¡€è®¾æ–½å±‚** - é€šç”¨æ”¯æ’‘æœåŠ¡

- é”™è¯¯ç±»å‹å®šä¹‰å’Œå¤„ç†
- å·¥å…·å‡½æ•°å’Œæ‰©å±•æ–¹æ³•
- æ—¥å¿—å’Œç›‘æ§æ”¯æŒ
- ç±»å‹å®šä¹‰å’Œå¸¸é‡

### ä¾èµ–ç®¡ç†åŸåˆ™

**å•å‘ä¾èµ–è§„åˆ™**ï¼š

- ä¸Šå±‚å¯ä»¥ä¾èµ–ä¸‹å±‚ï¼Œä¸¥ç¦ä¸‹å±‚ä¾èµ–ä¸Šå±‚
- åŒå±‚æ¨¡å—é—´é¿å…å¾ªç¯ä¾èµ–
- é€šè¿‡æ¥å£æŠ½è±¡é™ä½è€¦åˆåº¦

**ä¾èµ–æ³¨å…¥æ¨¡å¼**ï¼š

```rust
// âœ… é€šè¿‡å‚æ•°æ³¨å…¥ä¾èµ–
pub struct PcapReader {
    config: ReaderConfig,
    file_reader: PcapFileReader,
    index: PcapFileIndex,
    cache: FileInfoCache,
}

// âœ… ä½¿ç”¨ trait æŠ½è±¡ä¾èµ–
pub trait FileAccess {
    fn read_packet(&mut self) -> PcapResult<Option<DataPacket>>;
    fn write_packet(&mut self, packet: &DataPacket) -> PcapResult<()>;
    fn flush(&mut self) -> PcapResult<()>;
}
```

## ğŸ“ æ¨¡å—ç»„ç»‡è§„èŒƒ

### æ ‡å‡†ç›®å½•ç»“æ„

```
src/
â”œâ”€â”€ lib.rs                 # æ¨¡å—å£°æ˜å’Œé‡å¯¼å‡º
â”œâ”€â”€ api/                   # ç”¨æˆ·æ¥å£å±‚
â”‚   â”œâ”€â”€ mod.rs             # æ¥å£æ¨¡å—ç»Ÿä¸€å¯¼å‡º
â”‚   â”œâ”€â”€ reader.rs          # æ•°æ®é›†è¯»å–å™¨
â”‚   â””â”€â”€ writer.rs          # æ•°æ®é›†å†™å…¥å™¨
â”œâ”€â”€ business/              # ä¸šåŠ¡é€»è¾‘å±‚
â”‚   â”œâ”€â”€ mod.rs             # ä¸šåŠ¡æ¨¡å—ç»Ÿä¸€å¯¼å‡º
â”‚   â”œâ”€â”€ config.rs          # é…ç½®ç®¡ç†å’ŒéªŒè¯é€»è¾‘
â”‚   â”œâ”€â”€ cache.rs           # æ–‡ä»¶ä¿¡æ¯ç¼“å­˜ç®¡ç†
â”‚   â””â”€â”€ index/             # ç´¢å¼•ç³»ç»Ÿ
â”‚       â”œâ”€â”€ mod.rs         # ç´¢å¼•æ¨¡å—å…¥å£
â”‚       â”œâ”€â”€ manager.rs     # ç´¢å¼•ç®¡ç†å™¨
â”‚       â””â”€â”€ types.rs       # ç´¢å¼•æ•°æ®ç»“æ„
â”œâ”€â”€ data/                  # æ•°æ®è®¿é—®å±‚
â”‚   â”œâ”€â”€ mod.rs             # æ•°æ®æ¨¡å—ç»Ÿä¸€å¯¼å‡º
â”‚   â”œâ”€â”€ models.rs          # æ ¸å¿ƒæ•°æ®ç»“æ„
â”‚   â”œâ”€â”€ file_reader.rs     # å•æ–‡ä»¶è¯»å–å™¨
â”‚   â”œâ”€â”€ file_writer.rs     # å•æ–‡ä»¶å†™å…¥å™¨
â”‚   â””â”€â”€ formats.rs         # æ ¼å¼è§£æå’Œç”Ÿæˆ
â””â”€â”€ foundation/            # åŸºç¡€è®¾æ–½å±‚
    â”œâ”€â”€ mod.rs             # åŸºç¡€æ¨¡å—ç»Ÿä¸€å¯¼å‡º
    â”œâ”€â”€ error.rs           # é”™è¯¯ç±»å‹å®šä¹‰å’Œå¤„ç†
    â”œâ”€â”€ types.rs           # å…¬å…±ç±»å‹å’Œå¸¸é‡å®šä¹‰
    â””â”€â”€ utils.rs           # é€šç”¨å·¥å…·å‡½æ•°
```

### æ¨¡å—èŒè´£è§„èŒƒ

**ç”¨æˆ·æ¥å£å±‚ (`api/`)**ï¼š

- æä¾›ç”¨æˆ·å‹å¥½çš„ API æ¥å£ï¼ˆPcapReaderã€PcapWriterï¼‰
- è‡ªåŠ¨åŒ–èµ„æºç®¡ç†å’Œé”™è¯¯å¤„ç†
- éšè—å†…éƒ¨å®ç°å¤æ‚æ€§

**ä¸šåŠ¡é€»è¾‘å±‚ (`business/`)**ï¼š

- é…ç½®ç®¡ç†å’ŒéªŒè¯é€»è¾‘ï¼ˆReaderConfigã€WriterConfigï¼‰
- ç¼“å­˜ç­–ç•¥å’Œæ€§èƒ½ä¼˜åŒ–ï¼ˆFileInfoCacheï¼‰
- ç´¢å¼•ç³»ç»Ÿç®¡ç†ï¼ˆPcapFileIndexã€PidxIndexï¼‰

**æ•°æ®è®¿é—®å±‚ (`data/`)**ï¼š

- åº•å±‚æ–‡ä»¶ I/O æ“ä½œï¼ˆPcapFileReaderã€PcapFileWriterï¼‰
- æ•°æ®æ ¼å¼è§£æå’Œç”Ÿæˆï¼ˆPcapFormatProcessorï¼‰
- æ•°æ®æ¨¡å‹å®šä¹‰ï¼ˆDataPacketã€DatasetInfoã€FileInfoï¼‰

**åŸºç¡€è®¾æ–½å±‚ (`foundation/`)**ï¼š

- é”™è¯¯ç±»å‹å’Œå¤„ç†æœºåˆ¶ï¼ˆPcapErrorã€PcapResultï¼‰
- é€šç”¨å·¥å…·å‡½æ•°ï¼ˆByteArrayExtensionsã€DateTimeExtensionsï¼‰
- ç±»å‹å®šä¹‰å’Œå¸¸é‡ï¼ˆPcapErrorCodeã€constantsï¼‰

## ğŸ”Œ æ¥å£è®¾è®¡åŸåˆ™

### Trait è®¾è®¡è§„èŒƒ

è®¾è®¡å†…èšã€æ¾è€¦åˆçš„æ¥å£ï¼š

```rust
// âœ… èŒè´£å•ä¸€çš„ trait
pub trait PacketReader {
    fn read_packet(&mut self) -> PcapResult<Option<ValidatedPacket>>;
    fn read_packet_data_only(&mut self) -> PcapResult<Option<DataPacket>>;
    fn read_packets(&mut self, count: usize) -> PcapResult<Vec<ValidatedPacket>>;
    fn reset(&mut self) -> PcapResult<()>;
}

pub trait PacketWriter {
    fn write_packet(&mut self, packet: &DataPacket) -> PcapResult<()>;
    fn write_packets(&mut self, packets: &[DataPacket]) -> PcapResult<()>;
    fn flush(&mut self) -> PcapResult<()>;
}

// âœ… ç»„åˆè€Œéç»§æ‰¿
pub trait PacketProcessor: PacketReader + PacketWriter {}
```

### API ç®€åŒ–åŸåˆ™

- **è‡ªåŠ¨åŒ–ç®¡ç†**ï¼šèµ„æºåˆå§‹åŒ–å’Œæ¸…ç†è‡ªåŠ¨åŒ–
- **æ‰¹é‡æ“ä½œ**ï¼šæä¾›æ‰¹é‡å¤„ç†æ¥å£æå‡æ€§èƒ½
- **é»˜è®¤å®ç°**ï¼šä¸º trait æä¾›åˆç†çš„é»˜è®¤å®ç°
- **é”™è¯¯é€æ˜**ï¼šé”™è¯¯ä¿¡æ¯åŒ…å«è¶³å¤Ÿçš„ä¸Šä¸‹æ–‡

### åˆ†å±‚é…ç½®è®¾è®¡

```rust
// âœ… åˆ†å±‚é…ç½®ç»“æ„
#[derive(Debug, Clone)]
pub struct ReaderConfig {
    pub buffer_size: usize,        // ç¼“å†²åŒºå¤§å°ï¼ˆå­—èŠ‚ï¼‰
    pub index_cache_size: usize,   // ç´¢å¼•ç¼“å­˜å¤§å°ï¼ˆæ¡ç›®æ•°ï¼‰
}

#[derive(Debug, Clone)]
pub struct WriterConfig {
    pub buffer_size: usize,        // ç¼“å†²åŒºå¤§å°ï¼ˆå­—èŠ‚ï¼‰
    pub index_cache_size: usize,   // ç´¢å¼•ç¼“å­˜å¤§å°ï¼ˆæ¡ç›®æ•°ï¼‰
    pub max_packets_per_file: usize, // æ¯ä¸ªæ–‡ä»¶æœ€å¤§æ•°æ®åŒ…æ•°
    pub file_name_format: String,  // æ–‡ä»¶åæ ¼å¼
    pub auto_flush: bool,          // è‡ªåŠ¨åˆ·æ–°
}

// âœ… é¢„è®¾é…ç½®æ¨¡å¼
impl ReaderConfig {
    pub fn default() -> Self {
        Self {
            buffer_size: 8192,
            index_cache_size: 1000,
        }
    }
    
    pub fn high_performance() -> Self {
        Self {
            buffer_size: 65536,
            index_cache_size: 10000,
        }
    }
    
    pub fn low_memory() -> Self {
        Self {
            buffer_size: 1024,
            index_cache_size: 100,
        }
    }
}

// âœ… é…ç½®éªŒè¯
impl ReaderConfig {
    pub fn validate(&self) -> Result<(), String> {
        if self.buffer_size == 0 {
            return Err("ç¼“å†²åŒºå¤§å°ä¸èƒ½ä¸º0".to_string());
        }
        if self.index_cache_size == 0 {
            return Err("ç´¢å¼•ç¼“å­˜å¤§å°ä¸èƒ½ä¸º0".to_string());
        }
        Ok(())
    }
}
```

## ğŸ”„ ç”Ÿå‘½å‘¨æœŸç®¡ç†

### èµ„æºç®¡ç†æ¨¡å¼

```rust
// âœ… RAII æ¨¡å¼è‡ªåŠ¨ç®¡ç†èµ„æº
pub struct PcapWriter {
    config: WriterConfig,
    file_writer: PcapFileWriter,
    index: PcapFileIndex,
    cache: FileInfoCache,
    dataset_path: PathBuf,
    dataset_name: String,
    initialized: bool,
}

impl PcapWriter {
    pub fn new<P: AsRef<Path>>(base_path: P, dataset_name: &str) -> PcapResult<Self> {
        Self::new_with_config(base_path, dataset_name, WriterConfig::default())
    }
}

impl Drop for PcapWriter {
    fn drop(&mut self) {
        // è‡ªåŠ¨å®Œæˆfinalizeæ“ä½œ
        if self.initialized {
            if let Err(e) = self.finalize() {
                log::warn!("PcapWriter è‡ªåŠ¨æ¸…ç†å¤±è´¥: {}", e);
            }
        }
    }
}
```

### æ¨¡å—å‘½åè§„èŒƒ

- ä½¿ç”¨ `snake_case` å‘½åæ–‡ä»¶å’Œç›®å½•
- æŒ‰åŠŸèƒ½è€ŒéæŠ€æœ¯åˆ†ç»„
- æ¯ä¸ªæ¨¡å—èŒè´£å•ä¸€æ˜ç¡®
- ç›®å½•åä½“ç°æ¶æ„å±‚æ¬¡

## ğŸ“Š æ‰©å±•æ€§è®¾è®¡

### æ’ä»¶åŒ–æ¶æ„

```rust
// âœ… æ‰©å±•æ¥å£å®šä¹‰
pub trait PacketProcessor: Send + Sync {
    fn process_packet(&mut self, packet: &DataPacket) -> PcapResult<DataPacket>;
    fn process_packets(&mut self, packets: &[DataPacket]) -> PcapResult<Vec<DataPacket>>;
    fn reset(&mut self) -> PcapResult<()>;
}

// âœ… å¤„ç†å™¨ç®¡ç†å™¨
pub struct ProcessorManager {
    processors: HashMap<String, Box<dyn PacketProcessor>>,
}
```

### ç‰ˆæœ¬å…¼å®¹æ€§

- **æ¥å£ç‰ˆæœ¬åŒ–**ï¼šä½¿ç”¨è¯­ä¹‰åŒ–ç‰ˆæœ¬æ§åˆ¶
- **å‘åå…¼å®¹**ï¼šæ–°ç‰ˆæœ¬ä¿æŒæ—§æ¥å£å¯ç”¨
- **è¿ç§»æ”¯æŒ**ï¼šæä¾›æ•°æ®å’Œé…ç½®è¿ç§»å·¥å…·
- **ç‰¹æ€§é—¨æ§**ï¼šä½¿ç”¨ Cargo features æ§åˆ¶åŠŸèƒ½
