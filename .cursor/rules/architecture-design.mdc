---
alwaysApply: true
---
# 系统架构设计原则规范

## 🏗️ 分层架构设计

### 标准四层架构

严格遵循分层架构，确保系统的可维护性和可扩展性：

```
┌─────────────────────────────────────┐
│    用户接口层 (API Layer)           │  ← 对外提供服务接口
├─────────────────────────────────────┤
│    业务逻辑层 (Business Layer)      │  ← 核心业务逻辑实现
├─────────────────────────────────────┤
│    数据访问层 (Data Layer)          │  ← 数据操作和格式处理
├─────────────────────────────────────┤
│    基础设施层 (Infrastructure)      │  ← 工具函数和通用组件
└─────────────────────────────────────┘
```

### 层次职责定义

**用户接口层** - 简洁的对外接口

- 提供用户友好的 API
- 隐藏内部实现复杂性
- 处理参数验证和格式转换
- 实现资源的自动化管理

**业务逻辑层** - 核心功能实现

- 具体业务规则和算法
- 配置管理和策略控制
- 缓存和索引等性能优化
- 业务流程编排

**数据访问层** - 数据操作抽象

- 文件 I/O 和网络操作
- 数据序列化/反序列化
- 格式解析和生成
- 底层存储操作

**基础设施层** - 通用支撑服务

- 错误类型定义和处理
- 工具函数和扩展方法
- 日志和监控支持
- 类型定义和常量

### 依赖管理原则

**单向依赖规则**：

- 上层可以依赖下层，严禁下层依赖上层
- 同层模块间避免循环依赖
- 通过接口抽象降低耦合度

**依赖注入模式**：

```rust
// ✅ 通过参数注入依赖
pub struct PcapReader {
    config: ReaderConfig,
    file_reader: PcapFileReader,
    index: PcapFileIndex,
    cache: FileInfoCache,
}

// ✅ 使用 trait 抽象依赖
pub trait FileAccess {
    fn read_packet(&mut self) -> PcapResult<Option<DataPacket>>;
    fn write_packet(&mut self, packet: &DataPacket) -> PcapResult<()>;
    fn flush(&mut self) -> PcapResult<()>;
}
```

## 📁 模块组织规范

### 标准目录结构

```
src/
├── lib.rs                 # 模块声明和重导出
├── api/                   # 用户接口层
│   ├── mod.rs             # 接口模块统一导出
│   ├── reader.rs          # 数据集读取器
│   └── writer.rs          # 数据集写入器
├── business/              # 业务逻辑层
│   ├── mod.rs             # 业务模块统一导出
│   ├── config.rs          # 配置管理和验证逻辑
│   ├── cache.rs           # 文件信息缓存管理
│   └── index/             # 索引系统
│       ├── mod.rs         # 索引模块入口
│       ├── manager.rs     # 索引管理器
│       └── types.rs       # 索引数据结构
├── data/                  # 数据访问层
│   ├── mod.rs             # 数据模块统一导出
│   ├── models.rs          # 核心数据结构
│   ├── file_reader.rs     # 单文件读取器
│   ├── file_writer.rs     # 单文件写入器
│   └── formats.rs         # 格式解析和生成
└── foundation/            # 基础设施层
    ├── mod.rs             # 基础模块统一导出
    ├── error.rs           # 错误类型定义和处理
    ├── types.rs           # 公共类型和常量定义
    └── utils.rs           # 通用工具函数
```

### 模块职责规范

**用户接口层 (`api/`)**：

- 提供用户友好的 API 接口（PcapReader、PcapWriter）
- 自动化资源管理和错误处理
- 隐藏内部实现复杂性

**业务逻辑层 (`business/`)**：

- 配置管理和验证逻辑（ReaderConfig、WriterConfig）
- 缓存策略和性能优化（FileInfoCache）
- 索引系统管理（PcapFileIndex、PidxIndex）

**数据访问层 (`data/`)**：

- 底层文件 I/O 操作（PcapFileReader、PcapFileWriter）
- 数据格式解析和生成（PcapFormatProcessor）
- 数据模型定义（DataPacket、DatasetInfo、FileInfo）

**基础设施层 (`foundation/`)**：

- 错误类型和处理机制（PcapError、PcapResult）
- 通用工具函数（ByteArrayExtensions、DateTimeExtensions）
- 类型定义和常量（PcapErrorCode、constants）

## 🔌 接口设计原则

### Trait 设计规范

设计内聚、松耦合的接口：

```rust
// ✅ 职责单一的 trait
pub trait PacketReader {
    fn read_packet(&mut self) -> PcapResult<Option<ValidatedPacket>>;
    fn read_packet_data_only(&mut self) -> PcapResult<Option<DataPacket>>;
    fn read_packets(&mut self, count: usize) -> PcapResult<Vec<ValidatedPacket>>;
    fn reset(&mut self) -> PcapResult<()>;
}

pub trait PacketWriter {
    fn write_packet(&mut self, packet: &DataPacket) -> PcapResult<()>;
    fn write_packets(&mut self, packets: &[DataPacket]) -> PcapResult<()>;
    fn flush(&mut self) -> PcapResult<()>;
}

// ✅ 组合而非继承
pub trait PacketProcessor: PacketReader + PacketWriter {}
```

### API 简化原则

- **自动化管理**：资源初始化和清理自动化
- **批量操作**：提供批量处理接口提升性能
- **默认实现**：为 trait 提供合理的默认实现
- **错误透明**：错误信息包含足够的上下文

### 分层配置设计

```rust
// ✅ 分层配置结构
#[derive(Debug, Clone)]
pub struct ReaderConfig {
    pub buffer_size: usize,        // 缓冲区大小（字节）
    pub index_cache_size: usize,   // 索引缓存大小（条目数）
}

#[derive(Debug, Clone)]
pub struct WriterConfig {
    pub buffer_size: usize,        // 缓冲区大小（字节）
    pub index_cache_size: usize,   // 索引缓存大小（条目数）
    pub max_packets_per_file: usize, // 每个文件最大数据包数
    pub file_name_format: String,  // 文件名格式
    pub auto_flush: bool,          // 自动刷新
}

// ✅ 预设配置模式
impl ReaderConfig {
    pub fn default() -> Self {
        Self {
            buffer_size: 8192,
            index_cache_size: 1000,
        }
    }
    
    pub fn high_performance() -> Self {
        Self {
            buffer_size: 65536,
            index_cache_size: 10000,
        }
    }
    
    pub fn low_memory() -> Self {
        Self {
            buffer_size: 1024,
            index_cache_size: 100,
        }
    }
}

// ✅ 配置验证
impl ReaderConfig {
    pub fn validate(&self) -> Result<(), String> {
        if self.buffer_size == 0 {
            return Err("缓冲区大小不能为0".to_string());
        }
        if self.index_cache_size == 0 {
            return Err("索引缓存大小不能为0".to_string());
        }
        Ok(())
    }
}
```

## 🔄 生命周期管理

### 资源管理模式

```rust
// ✅ RAII 模式自动管理资源
pub struct PcapWriter {
    config: WriterConfig,
    file_writer: PcapFileWriter,
    index: PcapFileIndex,
    cache: FileInfoCache,
    dataset_path: PathBuf,
    dataset_name: String,
    initialized: bool,
}

impl PcapWriter {
    pub fn new<P: AsRef<Path>>(base_path: P, dataset_name: &str) -> PcapResult<Self> {
        Self::new_with_config(base_path, dataset_name, WriterConfig::default())
    }
}

impl Drop for PcapWriter {
    fn drop(&mut self) {
        // 自动完成finalize操作
        if self.initialized {
            if let Err(e) = self.finalize() {
                log::warn!("PcapWriter 自动清理失败: {}", e);
            }
        }
    }
}
```

### 模块命名规范

- 使用 `snake_case` 命名文件和目录
- 按功能而非技术分组
- 每个模块职责单一明确
- 目录名体现架构层次

## 📊 扩展性设计

### 插件化架构

```rust
// ✅ 扩展接口定义
pub trait PacketProcessor: Send + Sync {
    fn process_packet(&mut self, packet: &DataPacket) -> PcapResult<DataPacket>;
    fn process_packets(&mut self, packets: &[DataPacket]) -> PcapResult<Vec<DataPacket>>;
    fn reset(&mut self) -> PcapResult<()>;
}

// ✅ 处理器管理器
pub struct ProcessorManager {
    processors: HashMap<String, Box<dyn PacketProcessor>>,
}
```

### 版本兼容性

- **接口版本化**：使用语义化版本控制
- **向后兼容**：新版本保持旧接口可用
- **迁移支持**：提供数据和配置迁移工具
- **特性门控**：使用 Cargo features 控制功能
