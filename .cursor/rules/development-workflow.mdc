---
description: 开发流程和工具使用规范
alwaysApply: false
---
# 开发流程和工具使用规范

## 🔧 必需的开发工具链

### 代码质量检查工具

每次提交前必须通过以下检查：

```bash
# 代码格式化（必须）
cargo fmt --check

# 代码质量检查（必须，零警告）
cargo clippy -- -D warnings

# 类型检查（必须）
cargo check --all-targets --all-features

# 单元测试（必须全部通过）
cargo test

# 文档生成检查（必须）
cargo doc --no-deps --document-private-items
```

### 推荐的辅助工具

提升开发效率的工具：

```bash
# 自动监听文件变化并运行测试
cargo install cargo-watch
cargo watch -x test -x clippy

# 检查依赖的安全漏洞
cargo install cargo-audit
cargo audit

# 检查过时的依赖版本
cargo install cargo-outdated
cargo outdated

# 展开宏定义用于调试
cargo install cargo-expand
cargo expand module::macro_name

# 性能基准测试
cargo install cargo-criterion
cargo criterion
```

## 📋 代码提交工作流

### 提交前检查清单

确保每次提交都满足质量标准：

```bash
#!/bin/bash
# pre-commit-check.sh

echo "🔍 运行代码质量检查..."

# 1. 格式化检查
echo "检查代码格式..."
if ! cargo fmt --check; then
    echo "❌ 代码格式不规范，请运行: cargo fmt"
    exit 1
fi

# 2. Clippy 检查
echo "运行 Clippy 检查..."
if ! cargo clippy --all-targets --all-features -- -D warnings; then
    echo "❌ Clippy 检查失败，请修复警告"
    exit 1
fi

# 3. 测试检查
echo "运行测试..."
if ! cargo test; then
    echo "❌ 测试失败，请修复测试"
    exit 1
fi

# 4. 文档检查
echo "检查文档生成..."
if ! cargo doc --no-deps --document-private-items; then
    echo "❌ 文档生成失败，请修复文档注释"
    exit 1
fi

echo "✅ 所有检查通过，可以提交代码"
```

### Git 提交信息规范

使用规范化的提交信息格式：

```
<类型>(<范围>): <简短描述>

<详细描述>

<破坏性变更说明>
<关闭的 issue>
```

**类型标识：**

- `feat`: 新功能
- `fix`: Bug 修复
- `docs`: 文档更新
- `style`: 代码格式修改
- `refactor`: 代码重构
- `test`: 测试相关
- `chore`: 构建过程或辅助工具的变动

**示例：**

```
feat(reader): 添加批量读取 API

- 新增 read_batch 方法支持批量读取数据包
- 提供可配置的批次大小参数
- 优化内存使用，减少单次分配开销

性能提升: 批量读取比单个读取快 3-5 倍

Closes #123
```

## 🧪 测试策略和规范

### 测试层次结构

建立完整的测试金字塔：

```rust
// 1. 单元测试 - 测试单个函数/方法
#[cfg(test)]
mod unit_tests {
    use super::*;

    #[test]
    fn test_data_packet_creation() {
        let data = b"test data".to_vec();
        let packet = DataPacket::from_datetime(Utc::now(), data).unwrap();
        assert_eq!(packet.packet_length(), 9);
        assert!(packet.is_valid());
    }

    #[test]
    fn test_error_handling() {
        let invalid_data = vec![];
        let result = DataPacket::from_datetime(Utc::now(), invalid_data);
        assert!(result.is_err());
    }
}

// 2. 集成测试 - 测试模块间交互
#[cfg(test)]
mod integration_tests {
    use super::*;

    #[test]
    fn test_full_read_write_pipeline() {
        let temp_dir = tempfile::tempdir().unwrap();
        let mut writer = PcapWriter::new(temp_dir.path(), "test_dataset").unwrap();

        let data = b"test packet".to_vec();
        let packet = DataPacket::from_datetime(Utc::now(), data).unwrap();
        writer.write_packet(&packet).unwrap();
        writer.flush().unwrap();
        drop(writer);

        let mut reader = PcapReader::new(temp_dir.path(), "test_dataset").unwrap();
        let read_packet = reader.read_packet().unwrap().unwrap();
        assert!(read_packet.is_valid());
        assert_eq!(read_packet.packet_length(), 11);
    }
}

// 3. 性能测试 - 基准测试关键路径
#[cfg(test)]
mod bench_tests {
    use super::*;
    use criterion::{black_box, criterion_group, criterion_main, Criterion};

    fn benchmark_packet_processing(c: &mut Criterion) {
        let data = generate_test_packets(1000);

        c.bench_function("process_packets_1k", |b| {
            b.iter(|| {
                let temp_dir = tempfile::tempdir().unwrap();
                let mut writer = PcapWriter::new(temp_dir.path(), "bench").unwrap();
                for packet in &data {
                    black_box(writer.write_packet(packet).unwrap());
                }
                black_box(writer.flush().unwrap());
            })
        });
    }

    criterion_group!(benches, benchmark_packet_processing);
    criterion_main!(benches);
}
```

### 测试数据管理

```rust
// 测试工具模块
#[cfg(test)]
pub mod test_utils {
    use super::*;

    /// 创建标准测试配置
    pub fn create_test_reader_config() -> ReaderConfig {
        ReaderConfig {
            buffer_size: 1024,
            index_cache_size: 100,
        }
    }

    pub fn create_test_writer_config() -> WriterConfig {
        WriterConfig {
            buffer_size: 1024,
            index_cache_size: 100,
            max_packets_per_file: 10,
            file_name_format: "test_%Y%m%d_%H%M%S_%f".to_string(),
            auto_flush: true,
        }
    }

    /// 生成指定数量的测试数据包
    pub fn generate_test_packets(count: usize) -> Vec<DataPacket> {
        (0..count)
            .map(|i| {
                let data = format!("test_packet_{}", i).into_bytes();
                DataPacket::from_datetime(Utc::now(), data).unwrap()
            })
            .collect()
    }

    /// 创建临时测试目录
    pub fn create_temp_dir() -> tempfile::TempDir {
        tempfile::tempdir().expect("创建临时目录失败")
    }
}
```

## 📊 性能监控和优化

### 性能基准测试

建立性能基线和回归检测：

```rust
// benches/performance.rs
use criterion::{criterion_group, criterion_main, Criterion, BenchmarkId};
use pcapfile_io::*;

fn benchmark_different_sizes(c: &mut Criterion) {
    let mut group = c.benchmark_group("packet_processing");

    // 测试不同数据包数量的性能
    for size in [100, 1000, 10000].iter() {
        group.bench_with_input(
            BenchmarkId::new("write_packets", size),
            size,
            |b, &size| {
                let temp_dir = tempfile::tempdir().unwrap();
                let packets = generate_test_packets(size);
                b.iter(|| {
                    let mut writer = PcapWriter::new(temp_dir.path(), "bench").unwrap();
                    for packet in &packets {
                        writer.write_packet(packet).unwrap();
                    }
                    writer.flush().unwrap();
                })
            },
        );
    }
    group.finish();
}

criterion_group!(benches, benchmark_different_sizes);
criterion_main!(benches);
```

### 内存使用监控

```rust
#[cfg(test)]
mod memory_tests {
    use super::*;

    #[test]
    fn test_memory_usage() {
        let initial_memory = get_memory_usage();

        {
            let temp_dir = tempfile::tempdir().unwrap();
            let mut writer = PcapWriter::new(temp_dir.path(), "memory_test").unwrap();
            let large_packets = generate_test_packets(10000);

            for packet in &large_packets {
                writer.write_packet(packet).unwrap();
            }
            writer.flush().unwrap();
            drop(writer);
        } // writer 在此处析构

        // 强制垃圾回收
        std::thread::sleep(Duration::from_millis(100));

        let final_memory = get_memory_usage();
        let memory_leak = final_memory - initial_memory;

        // 允许少量内存增长，但不应有明显泄漏
        assert!(memory_leak < 1024 * 1024, "可能存在内存泄漏: {} bytes", memory_leak);
    }
}
```

## 📚 文档维护规范

### API 文档要求

所有公共接口必须有完整文档：

````rust
/// 模块级文档
///
/// 这个模块提供数据处理的核心功能，包括：
/// - 数据验证和格式化
/// - 批量处理和性能优化
/// - 错误处理和恢复机制
///
/// # 使用示例
/// ```rust
/// use my_crate::processor::*;
///
/// let config = ProcessorConfig::default();
/// let processor = DataProcessor::new(config)?;
/// let result = processor.process(&input_data)?;
/// ```

// 为复杂算法提供详细说明
impl DataProcessor {
    /// 使用优化的批量处理算法
    ///
    /// # 算法说明
    /// 1. 将输入数据按配置的批次大小分组
    /// 2. 并行处理每个批次以提高效率
    /// 3. 合并结果并进行最终验证
    ///
    /// # 时间复杂度
    /// O(n) 其中 n 是输入数据的总数量
    ///
    /// # 内存复杂度
    /// O(batch_size) 每个批次的内存使用量
    pub fn process_optimized(&mut self, data: &[InputItem]) -> Result<ProcessResult> {
        // 实现细节...
    }
}
````

### 示例代码要求

```rust
// examples/dataset_usage.rs
//! 数据集使用示例
//!
//! 演示如何使用库的核心功能进行PCAP文件读写

use pcapfile_io::*;
use chrono::Utc;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 1. 创建数据集写入器
    let mut writer = PcapWriter::new("./data", "example_dataset")?;

    // 2. 创建测试数据包
    let packets = vec![
        DataPacket::from_datetime(Utc::now(), b"packet_1".to_vec())?,
        DataPacket::from_datetime(Utc::now(), b"packet_2".to_vec())?,
        DataPacket::from_datetime(Utc::now(), b"packet_3".to_vec())?,
    ];

    // 3. 写入数据包
    for packet in &packets {
        writer.write_packet(packet)?;
    }
    writer.flush()?;
    drop(writer); // 自动完成finalize

    // 4. 读取数据包
    let mut reader = PcapReader::new("./data", "example_dataset")?;
    let mut read_count = 0;
    let mut valid_count = 0;

    while let Some(validated_packet) = reader.read_packet()? {
        read_count += 1;
        if validated_packet.is_valid() {
            valid_count += 1;
            println!("读取到有效数据包: {} 字节", validated_packet.packet_length());
        } else {
            println!("读取到损坏数据包: {} 字节", validated_packet.packet_length());
        }
    }

    // 5. 输出结果
    println!("处理完成:");
    println!("  写入数据包: {} 条", packets.len());
    println!("  读取数据包: {} 条", read_count);
    println!("  有效数据包: {} 条", valid_count);

    Ok(())
}
```
