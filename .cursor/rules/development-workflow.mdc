---
description: å¼€å‘æµç¨‹å’Œå·¥å…·ä½¿ç”¨è§„èŒƒ
alwaysApply: false
---
# å¼€å‘æµç¨‹å’Œå·¥å…·ä½¿ç”¨è§„èŒƒ

## ğŸ”§ å¿…éœ€çš„å¼€å‘å·¥å…·é“¾

### ä»£ç è´¨é‡æ£€æŸ¥å·¥å…·

æ¯æ¬¡æäº¤å‰å¿…é¡»é€šè¿‡ä»¥ä¸‹æ£€æŸ¥ï¼š

```bash
# ä»£ç æ ¼å¼åŒ–ï¼ˆå¿…é¡»ï¼‰
cargo fmt --check

# ä»£ç è´¨é‡æ£€æŸ¥ï¼ˆå¿…é¡»ï¼Œé›¶è­¦å‘Šï¼‰
cargo clippy -- -D warnings

# ç±»å‹æ£€æŸ¥ï¼ˆå¿…é¡»ï¼‰
cargo check --all-targets --all-features

# å•å…ƒæµ‹è¯•ï¼ˆå¿…é¡»å…¨éƒ¨é€šè¿‡ï¼‰
cargo test

# æ–‡æ¡£ç”Ÿæˆæ£€æŸ¥ï¼ˆå¿…é¡»ï¼‰
cargo doc --no-deps --document-private-items
```

### æ¨èçš„è¾…åŠ©å·¥å…·

æå‡å¼€å‘æ•ˆç‡çš„å·¥å…·ï¼š

```bash
# è‡ªåŠ¨ç›‘å¬æ–‡ä»¶å˜åŒ–å¹¶è¿è¡Œæµ‹è¯•
cargo install cargo-watch
cargo watch -x test -x clippy

# æ£€æŸ¥ä¾èµ–çš„å®‰å…¨æ¼æ´
cargo install cargo-audit
cargo audit

# æ£€æŸ¥è¿‡æ—¶çš„ä¾èµ–ç‰ˆæœ¬
cargo install cargo-outdated
cargo outdated

# å±•å¼€å®å®šä¹‰ç”¨äºè°ƒè¯•
cargo install cargo-expand
cargo expand module::macro_name

# æ€§èƒ½åŸºå‡†æµ‹è¯•
cargo install cargo-criterion
cargo criterion
```

## ğŸ“‹ ä»£ç æäº¤å·¥ä½œæµ

### æäº¤å‰æ£€æŸ¥æ¸…å•

ç¡®ä¿æ¯æ¬¡æäº¤éƒ½æ»¡è¶³è´¨é‡æ ‡å‡†ï¼š

```bash
#!/bin/bash
# pre-commit-check.sh

echo "ğŸ” è¿è¡Œä»£ç è´¨é‡æ£€æŸ¥..."

# 1. æ ¼å¼åŒ–æ£€æŸ¥
echo "æ£€æŸ¥ä»£ç æ ¼å¼..."
if ! cargo fmt --check; then
    echo "âŒ ä»£ç æ ¼å¼ä¸è§„èŒƒï¼Œè¯·è¿è¡Œ: cargo fmt"
    exit 1
fi

# 2. Clippy æ£€æŸ¥
echo "è¿è¡Œ Clippy æ£€æŸ¥..."
if ! cargo clippy --all-targets --all-features -- -D warnings; then
    echo "âŒ Clippy æ£€æŸ¥å¤±è´¥ï¼Œè¯·ä¿®å¤è­¦å‘Š"
    exit 1
fi

# 3. æµ‹è¯•æ£€æŸ¥
echo "è¿è¡Œæµ‹è¯•..."
if ! cargo test; then
    echo "âŒ æµ‹è¯•å¤±è´¥ï¼Œè¯·ä¿®å¤æµ‹è¯•"
    exit 1
fi

# 4. æ–‡æ¡£æ£€æŸ¥
echo "æ£€æŸ¥æ–‡æ¡£ç”Ÿæˆ..."
if ! cargo doc --no-deps --document-private-items; then
    echo "âŒ æ–‡æ¡£ç”Ÿæˆå¤±è´¥ï¼Œè¯·ä¿®å¤æ–‡æ¡£æ³¨é‡Š"
    exit 1
fi

echo "âœ… æ‰€æœ‰æ£€æŸ¥é€šè¿‡ï¼Œå¯ä»¥æäº¤ä»£ç "
```

### Git æäº¤ä¿¡æ¯è§„èŒƒ

ä½¿ç”¨è§„èŒƒåŒ–çš„æäº¤ä¿¡æ¯æ ¼å¼ï¼š

```
<ç±»å‹>(<èŒƒå›´>): <ç®€çŸ­æè¿°>

<è¯¦ç»†æè¿°>

<ç ´åæ€§å˜æ›´è¯´æ˜>
<å…³é—­çš„ issue>
```

**ç±»å‹æ ‡è¯†ï¼š**

- `feat`: æ–°åŠŸèƒ½
- `fix`: Bug ä¿®å¤
- `docs`: æ–‡æ¡£æ›´æ–°
- `style`: ä»£ç æ ¼å¼ä¿®æ”¹
- `refactor`: ä»£ç é‡æ„
- `test`: æµ‹è¯•ç›¸å…³
- `chore`: æ„å»ºè¿‡ç¨‹æˆ–è¾…åŠ©å·¥å…·çš„å˜åŠ¨

**ç¤ºä¾‹ï¼š**

```
feat(reader): æ·»åŠ æ‰¹é‡è¯»å– API

- æ–°å¢ read_batch æ–¹æ³•æ”¯æŒæ‰¹é‡è¯»å–æ•°æ®åŒ…
- æä¾›å¯é…ç½®çš„æ‰¹æ¬¡å¤§å°å‚æ•°
- ä¼˜åŒ–å†…å­˜ä½¿ç”¨ï¼Œå‡å°‘å•æ¬¡åˆ†é…å¼€é”€

æ€§èƒ½æå‡: æ‰¹é‡è¯»å–æ¯”å•ä¸ªè¯»å–å¿« 3-5 å€

Closes #123
```

## ğŸ§ª æµ‹è¯•ç­–ç•¥å’Œè§„èŒƒ

### æµ‹è¯•å±‚æ¬¡ç»“æ„

å»ºç«‹å®Œæ•´çš„æµ‹è¯•é‡‘å­—å¡”ï¼š

```rust
// 1. å•å…ƒæµ‹è¯• - æµ‹è¯•å•ä¸ªå‡½æ•°/æ–¹æ³•
#[cfg(test)]
mod unit_tests {
    use super::*;

    #[test]
    fn test_data_packet_creation() {
        let data = b"test data".to_vec();
        let packet = DataPacket::from_datetime(Utc::now(), data).unwrap();
        assert_eq!(packet.packet_length(), 9);
        assert!(packet.is_valid());
    }

    #[test]
    fn test_error_handling() {
        let invalid_data = vec![];
        let result = DataPacket::from_datetime(Utc::now(), invalid_data);
        assert!(result.is_err());
    }
}

// 2. é›†æˆæµ‹è¯• - æµ‹è¯•æ¨¡å—é—´äº¤äº’
#[cfg(test)]
mod integration_tests {
    use super::*;

    #[test]
    fn test_full_read_write_pipeline() {
        let temp_dir = tempfile::tempdir().unwrap();
        let mut writer = PcapWriter::new(temp_dir.path(), "test_dataset").unwrap();

        let data = b"test packet".to_vec();
        let packet = DataPacket::from_datetime(Utc::now(), data).unwrap();
        writer.write_packet(&packet).unwrap();
        writer.flush().unwrap();
        drop(writer);

        let mut reader = PcapReader::new(temp_dir.path(), "test_dataset").unwrap();
        let read_packet = reader.read_packet().unwrap().unwrap();
        assert!(read_packet.is_valid());
        assert_eq!(read_packet.packet_length(), 11);
    }
}

// 3. æ€§èƒ½æµ‹è¯• - åŸºå‡†æµ‹è¯•å…³é”®è·¯å¾„
#[cfg(test)]
mod bench_tests {
    use super::*;
    use criterion::{black_box, criterion_group, criterion_main, Criterion};

    fn benchmark_packet_processing(c: &mut Criterion) {
        let data = generate_test_packets(1000);

        c.bench_function("process_packets_1k", |b| {
            b.iter(|| {
                let temp_dir = tempfile::tempdir().unwrap();
                let mut writer = PcapWriter::new(temp_dir.path(), "bench").unwrap();
                for packet in &data {
                    black_box(writer.write_packet(packet).unwrap());
                }
                black_box(writer.flush().unwrap());
            })
        });
    }

    criterion_group!(benches, benchmark_packet_processing);
    criterion_main!(benches);
}
```

### æµ‹è¯•æ•°æ®ç®¡ç†

```rust
// æµ‹è¯•å·¥å…·æ¨¡å—
#[cfg(test)]
pub mod test_utils {
    use super::*;

    /// åˆ›å»ºæ ‡å‡†æµ‹è¯•é…ç½®
    pub fn create_test_reader_config() -> ReaderConfig {
        ReaderConfig {
            buffer_size: 1024,
            index_cache_size: 100,
        }
    }

    pub fn create_test_writer_config() -> WriterConfig {
        WriterConfig {
            buffer_size: 1024,
            index_cache_size: 100,
            max_packets_per_file: 10,
            file_name_format: "test_%Y%m%d_%H%M%S_%f".to_string(),
            auto_flush: true,
        }
    }

    /// ç”ŸæˆæŒ‡å®šæ•°é‡çš„æµ‹è¯•æ•°æ®åŒ…
    pub fn generate_test_packets(count: usize) -> Vec<DataPacket> {
        (0..count)
            .map(|i| {
                let data = format!("test_packet_{}", i).into_bytes();
                DataPacket::from_datetime(Utc::now(), data).unwrap()
            })
            .collect()
    }

    /// åˆ›å»ºä¸´æ—¶æµ‹è¯•ç›®å½•
    pub fn create_temp_dir() -> tempfile::TempDir {
        tempfile::tempdir().expect("åˆ›å»ºä¸´æ—¶ç›®å½•å¤±è´¥")
    }
}
```

## ğŸ“Š æ€§èƒ½ç›‘æ§å’Œä¼˜åŒ–

### æ€§èƒ½åŸºå‡†æµ‹è¯•

å»ºç«‹æ€§èƒ½åŸºçº¿å’Œå›å½’æ£€æµ‹ï¼š

```rust
// benches/performance.rs
use criterion::{criterion_group, criterion_main, Criterion, BenchmarkId};
use pcapfile_io::*;

fn benchmark_different_sizes(c: &mut Criterion) {
    let mut group = c.benchmark_group("packet_processing");

    // æµ‹è¯•ä¸åŒæ•°æ®åŒ…æ•°é‡çš„æ€§èƒ½
    for size in [100, 1000, 10000].iter() {
        group.bench_with_input(
            BenchmarkId::new("write_packets", size),
            size,
            |b, &size| {
                let temp_dir = tempfile::tempdir().unwrap();
                let packets = generate_test_packets(size);
                b.iter(|| {
                    let mut writer = PcapWriter::new(temp_dir.path(), "bench").unwrap();
                    for packet in &packets {
                        writer.write_packet(packet).unwrap();
                    }
                    writer.flush().unwrap();
                })
            },
        );
    }
    group.finish();
}

criterion_group!(benches, benchmark_different_sizes);
criterion_main!(benches);
```

### å†…å­˜ä½¿ç”¨ç›‘æ§

```rust
#[cfg(test)]
mod memory_tests {
    use super::*;

    #[test]
    fn test_memory_usage() {
        let initial_memory = get_memory_usage();

        {
            let temp_dir = tempfile::tempdir().unwrap();
            let mut writer = PcapWriter::new(temp_dir.path(), "memory_test").unwrap();
            let large_packets = generate_test_packets(10000);

            for packet in &large_packets {
                writer.write_packet(packet).unwrap();
            }
            writer.flush().unwrap();
            drop(writer);
        } // writer åœ¨æ­¤å¤„ææ„

        // å¼ºåˆ¶åƒåœ¾å›æ”¶
        std::thread::sleep(Duration::from_millis(100));

        let final_memory = get_memory_usage();
        let memory_leak = final_memory - initial_memory;

        // å…è®¸å°‘é‡å†…å­˜å¢é•¿ï¼Œä½†ä¸åº”æœ‰æ˜æ˜¾æ³„æ¼
        assert!(memory_leak < 1024 * 1024, "å¯èƒ½å­˜åœ¨å†…å­˜æ³„æ¼: {} bytes", memory_leak);
    }
}
```

## ğŸ“š æ–‡æ¡£ç»´æŠ¤è§„èŒƒ

### API æ–‡æ¡£è¦æ±‚

æ‰€æœ‰å…¬å…±æ¥å£å¿…é¡»æœ‰å®Œæ•´æ–‡æ¡£ï¼š

````rust
/// æ¨¡å—çº§æ–‡æ¡£
///
/// è¿™ä¸ªæ¨¡å—æä¾›æ•°æ®å¤„ç†çš„æ ¸å¿ƒåŠŸèƒ½ï¼ŒåŒ…æ‹¬ï¼š
/// - æ•°æ®éªŒè¯å’Œæ ¼å¼åŒ–
/// - æ‰¹é‡å¤„ç†å’Œæ€§èƒ½ä¼˜åŒ–
/// - é”™è¯¯å¤„ç†å’Œæ¢å¤æœºåˆ¶
///
/// # ä½¿ç”¨ç¤ºä¾‹
/// ```rust
/// use my_crate::processor::*;
///
/// let config = ProcessorConfig::default();
/// let processor = DataProcessor::new(config)?;
/// let result = processor.process(&input_data)?;
/// ```

// ä¸ºå¤æ‚ç®—æ³•æä¾›è¯¦ç»†è¯´æ˜
impl DataProcessor {
    /// ä½¿ç”¨ä¼˜åŒ–çš„æ‰¹é‡å¤„ç†ç®—æ³•
    ///
    /// # ç®—æ³•è¯´æ˜
    /// 1. å°†è¾“å…¥æ•°æ®æŒ‰é…ç½®çš„æ‰¹æ¬¡å¤§å°åˆ†ç»„
    /// 2. å¹¶è¡Œå¤„ç†æ¯ä¸ªæ‰¹æ¬¡ä»¥æé«˜æ•ˆç‡
    /// 3. åˆå¹¶ç»“æœå¹¶è¿›è¡Œæœ€ç»ˆéªŒè¯
    ///
    /// # æ—¶é—´å¤æ‚åº¦
    /// O(n) å…¶ä¸­ n æ˜¯è¾“å…¥æ•°æ®çš„æ€»æ•°é‡
    ///
    /// # å†…å­˜å¤æ‚åº¦
    /// O(batch_size) æ¯ä¸ªæ‰¹æ¬¡çš„å†…å­˜ä½¿ç”¨é‡
    pub fn process_optimized(&mut self, data: &[InputItem]) -> Result<ProcessResult> {
        // å®ç°ç»†èŠ‚...
    }
}
````

### ç¤ºä¾‹ä»£ç è¦æ±‚

```rust
// examples/dataset_usage.rs
//! æ•°æ®é›†ä½¿ç”¨ç¤ºä¾‹
//!
//! æ¼”ç¤ºå¦‚ä½•ä½¿ç”¨åº“çš„æ ¸å¿ƒåŠŸèƒ½è¿›è¡ŒPCAPæ–‡ä»¶è¯»å†™

use pcapfile_io::*;
use chrono::Utc;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 1. åˆ›å»ºæ•°æ®é›†å†™å…¥å™¨
    let mut writer = PcapWriter::new("./data", "example_dataset")?;

    // 2. åˆ›å»ºæµ‹è¯•æ•°æ®åŒ…
    let packets = vec![
        DataPacket::from_datetime(Utc::now(), b"packet_1".to_vec())?,
        DataPacket::from_datetime(Utc::now(), b"packet_2".to_vec())?,
        DataPacket::from_datetime(Utc::now(), b"packet_3".to_vec())?,
    ];

    // 3. å†™å…¥æ•°æ®åŒ…
    for packet in &packets {
        writer.write_packet(packet)?;
    }
    writer.flush()?;
    drop(writer); // è‡ªåŠ¨å®Œæˆfinalize

    // 4. è¯»å–æ•°æ®åŒ…
    let mut reader = PcapReader::new("./data", "example_dataset")?;
    let mut read_count = 0;
    let mut valid_count = 0;

    while let Some(validated_packet) = reader.read_packet()? {
        read_count += 1;
        if validated_packet.is_valid() {
            valid_count += 1;
            println!("è¯»å–åˆ°æœ‰æ•ˆæ•°æ®åŒ…: {} å­—èŠ‚", validated_packet.packet_length());
        } else {
            println!("è¯»å–åˆ°æŸåæ•°æ®åŒ…: {} å­—èŠ‚", validated_packet.packet_length());
        }
    }

    // 5. è¾“å‡ºç»“æœ
    println!("å¤„ç†å®Œæˆ:");
    println!("  å†™å…¥æ•°æ®åŒ…: {} æ¡", packets.len());
    println!("  è¯»å–æ•°æ®åŒ…: {} æ¡", read_count);
    println!("  æœ‰æ•ˆæ•°æ®åŒ…: {} æ¡", valid_count);

    Ok(())
}
```
